col <- spTransform(col, CRSobj = CRS(proj4string(gps2)))
#generate plot
xlim <- gps2@bbox[1,] + c(3, 0)
ylim <- gps2@bbox[2,] + c(-1, 1)
map_tuungane <- function(){
par(mar = c(0.5, 0.5, 0.5, 0.5))
plot(col, xlim = xlim, ylim = ylim, lwd = .1)
plot(gps2, add=TRUE, #pch = 21,
pch = c(21, 24)[factor(gps2$IDV_RAPID)],
bg = alpha(c("white", "black")[factor(gps2$TUUNGANE)], .6), cex = .4, lwd = .7)
text(x=c(26.7, 28.5, 28, 26.4), y = c(-3.8,-3.7, -6.8, -9), labels = c("Maniema", "South Kivu", "Tanganyika", "Haut Katanga"), cex = .8)
box()
scalebar(200, xy = c(29.6, -11.5), type = "bar", below = "km",
lwd = 3, divs = 3, cex = .6)
legend(29, -8.7, legend=c("Tuungane and RAPID", "Tuungane only", "RAPID only", "None"),
pch = c(24, 21, 24, 21),
pt.bg = alpha(c("black","black","white","white"), .6), bty = "n",
cex = .6, pt.cex = .8, text.width = 1.5, y.intersp = 1, x.intersp = .8,
inset=0.05)
# legend(29.6, -10, legend = c("Rapid", "Control"),
#        pch = c(24, 24), bty = "n",
#        cex = .8, pt.cex = 1.2, text.width = 1.5, y.intersp = 1, x.intersp = .8,
#        inset=0.05)
}
map_tuungane()
#output map to .pdf
if(saving){
pdf(paste0(output_folder, "/Fig1_TuunganeMap.pdf"), width = 3, height = 5)
map_tuungane()
dev.off()
}
DIS = unique(D$DISTRICT)
DISTRICT=D$DISTRICT
CHEF = D$CHEF
fig_timeline <- function(){
par(mfrow=c(2,2))
T1a = 	as.Date(D$lottery_date_med, origin="1960-01-01")
T1b = 	as.Date(D$T1_end_cdv_med, origin="1960-01-01")
T1c = 	as.Date(D$T1_end_cdc_med, origin="1960-01-01")
Ra = 	as.Date(D$stepA, origin="1960-01-01")
Rb = 	as.Date(D$stepD, origin="1960-01-01")
up = .2
#	lshift = 320
lshift = 800
RANGE=c(min(T1a), max(Rb,T1c))
RANGE2 = as.Date(seq(RANGE[1], RANGE[2], 60))
DISTRICT[DISTRICT=="SUD KIVU"] <- "SOUTH KIVU"
D$DISTRICT[D$DISTRICT=="SUD KIVU"] <- "SOUTH KIVU"
DIS[DIS=="SUD KIVU"] <- "SOUTH KIVU"
for(j in 1:length(DIS)){
CH = unique(CHEF[DISTRICT == DIS[j]])
DI = DIS[j]
o = rank(T1a[DISTRICT == DIS[j]])
plot(RANGE, RANGE, main=DI, ylim = c(0, length(CH)+1), xlim=c(min(RANGE)-lshift, max(RANGE)), axes=F,  xlab="", ylab = "", cex.main=2)
axis(1, at=RANGE2, labels=format(RANGE2, "%b %Y"), las=1, tick=F, cex.axis=1.5)
box()
for(i in (1:length(CH))){
j = o[i]
# Thin line:
segments(T1a[CHEF==CH[i]],j, T1c[CHEF==CH[i]],j, col="black")
# Thick line:
segments(T1a[CHEF==CH[i]],j, T1b[CHEF==CH[i]],j, col="black", lwd=6)
# Red line:
segments(Ra[CHEF==CH[i]] ,j+up, Rb[CHEF==CH[i]],j+up, col="red", lwd=3)
text(min(RANGE)-lshift,j, CH[i], pos=4, cex=1.3)
}
}
}
fig_timeline()
#output figure to .pdf
if(saving){
pdf(file=paste0(output_folder, "/Fig2_Timeline.pdf"), width=13, height=15)
fig_timeline()
dev.off()
}
#rescale inequality of private benefits
res_main_table <- main_table
v <- which(rownames(main_table) %in% c("ineq_benef"))
res_main_table[v, ] <- res_main_table[v, ]/10
#rescale large mechanism vars
v <- which(rownames(mechanisms_table) %in% c("part", "corr", "accep", "male_d","inter"))
v2 <- which(rownames(mechanisms_table) %in% c("part"))
res_mechanisms_table <- mechanisms_table
res_mechanisms_table[v, ] <- res_mechanisms_table[v, ]/10
res_mechanisms_table[v2, ] <- res_mechanisms_table[v2, ]/10
plot_main <- function(b, se, rnames, title, side = 2){
xlimit <- max(abs(c(b-1.96*se, b+1.96*se)))
plot(x = b,
y = 1:length(b), xlim = c(-xlimit-.2, xlimit+.2),
xlab = "", pch = 19, axes = FALSE, ylim = c(.5,length(b)+.5),
ylab = "", main = title)
# text(x = min(b-1.96*se)-.8, y = 1:nrow(main_table), labels = rev(capture_var_names), pos = 4, cex = .8)
axis(1)
axis(2, at = 1:length(b), labels = rnames, las = 1, tick = FALSE, side = side)
segments(x0 = b-1.96*se, y0=1:length(b), x1 = b+1.96*se)
segments(x0 = b-1.96*se, y0=1:length(b), x1 = b+1.96*se)
abline(v=0, col = "grey")
# box()
}
PARTICIPATION_NAMES  <- mech_var_names[1:5]
ACCOUNTABILITY_NAMES <- mech_var_names[6:7]
TRANSPARENCY_NAMES   <- mech_var_names[8:10]
fig_mechanisms <- function(){
# ticktextsize=1
mar.default <- c(4,14,4,2) + 0.1
par(mfrow = c(5,2),mar = mar.default + c(0, 2, 0, 0))
layout(matrix(c(1,1,1,3,3,2,2,2,4,4), ncol = 2))
# par(mfrow=c(2,2),  mar=c(0,0,0,0))
b  <- as.numeric(res_main_table[,"Effect"])
se <- as.numeric(gsub("\\(|\\)", "", res_main_table[,"std_error"]))
se_0  <- as.numeric(res_main_table[,"control.sd"])
plot_main(
rev(b),#/se_0),
rev(se),#/se_0),
rnames = rev(capture_var_names),
title = "Capture")#, tick=0.4, norm=1, ticktextsize=1)
b  <- as.numeric(res_mechanisms_table[ c("part", "inter", "male_d", "sel", "compos"), "Effect" ])
se <- as.numeric(gsub("\\(|\\)", "", res_mechanisms_table[c("part", "inter", "male_d", "sel", "compos"), "std_error"]))
se_0 <-  as.numeric(res_mechanisms_table[ c("part", "inter", "male_d", "sel", "compos"), "control.sd" ])
plot_main(
rev(b),#/se_0),
rev(se),#/se_0),
rnames=    rev(PARTICIPATION_NAMES),
title = "Participation")#, tick=.3, norm=1, ticktextsize=1)
b  <- as.numeric(res_mechanisms_table[ c("mech", "compl"),"Effect" ])
se <- as.numeric(gsub("\\(|\\)", "", mechanisms_table[c("mech", "compl"), "std_error"]))
se_0 <-  as.numeric(res_mechanisms_table[ c("mech", "compl"), "control.sd" ])
plot_main(
rev(b),#/se_0),
rev(se),#/se_0),
rnames=    rev(ACCOUNTABILITY_NAMES),
title = "Accountability")#, tick=.3, norm=1, ticktextsize=1)
b  <- as.numeric(res_mechanisms_table[ c("corr", "accep", "accoun"), "Effect" ])
se <- as.numeric(gsub("\\(|\\)", "", res_mechanisms_table[c("corr", "accep", "accoun" ), "std_error"]))
se_0   <- as.numeric(res_mechanisms_table[ c("corr", "accep", "accoun"), "control.sd" ])
plot_main(
rev(b),#/se_0),
rev(se),#/se_0),
rnames=    rev(TRANSPARENCY_NAMES),
title = "Transparency")#, tick=.3, norm=1, ticktextsize=1)
}
fig_mechanisms()
#output figure to .pdf
if(saving){
pdf(paste0(output_folder, "/Fig3_MainResults.pdf"), width = 11, height = 8)
fig_mechanisms()
dev.off()
}
# This defines a "translucent white" and a  "translucent black"
colors = c(rgb(1,1,1,.8), rgb(0,0,0,.8))
# Tuungane vs Control
TYPE1 =	1 +  1*(X$TUUNGANE==1)
col  = rainbow(2)
table(TYPE1)
# 5km data
X5 = X[X$NOTEXTREME==1,]
TYPE5 =1 +  1*(X5$TUUNGANE==1) + 2*(X5$INDIRECT==1)
col  = rainbow(4)
table(TYPE5)
# 20km data
X20 = X20[X20$NOTEXTREME==1,]
TYPE20 =1 +  1*(X20$TUUNGANE==1) + 2*(X20$INDIRECT==1)
col  = rainbow(4)
table(TYPE20)
proj4string(drc.map.test) <- CRS("+proj=longlat +datum=WGS84 +ellps=WGS84")
summary(drc.map.test) # This shows you the relevant coordinates to work from
# Plot maps
fig_spillovers <- function(){
# Plot Spillovers for example HK
pointsize = 1.5
par(mfrow=c(1,3))
plot(drc.map.test, xlim=c(26, 29), ylim=c(-11.8,-10)); title("All Units in Haut Katanga", cex.main=1.6)
for(j in sample(length(X$latitude))) points(X$longitude[j], X$latitude[j], bg=colors[TYPE1[j]], pch = 21, cex=pointsize)
lines(c(26.5,26.9),c(-12.2,-12.2), lwd=2)
lines(c(26.5,26.5),c(-12.15,-12.25), lwd=2, lend=2)
lines(c(26.9,26.9),c(-12.15,-12.25), lwd=2, lend=2)
text(26.9,-12.2, "50 KM", pos=4)
box()
plot(drc.map.test, xlim=c(26, 29), ylim=c(-11.8,-10)); title("5km Spillover Effects Subsample", cex.main=1.6)
for(j in sample(nrow(X5))) {
if(X5$INDIRECT[j]==1) points(X5$longitude[j], X5$latitude[j], pch = 8, cex=pointsize, col = colors[2])
points(X5$longitude[j], X5$latitude[j], bg=colors[X5$TUUNGANE[j]+1], pch = 21, cex=pointsize)}
lines(c(26.5,26.9),c(-12.2,-12.2), lwd=2)
lines(c(26.5,26.5),c(-12.15,-12.25), lwd=2, lend=2)
lines(c(26.9,26.9),c(-12.15,-12.25), lwd=2, lend=2)
text(26.9,-12.2, "50 KM", pos=4)
box()
plot(drc.map.test, xlim=c(26, 29), ylim=c(-11.8,-10)); title("20km Spillover Effects Subsample", cex.main=1.6)
for(j in sample(nrow(X20))) {
if(X20$INDIRECT[j]==1) points(X20$longitude[j], X20$latitude[j], pch = 8, cex=pointsize, col = colors[2])
points(X20$longitude[j], X20$latitude[j], bg=colors[X20$TUUNGANE[j]+1], pch = 21, cex=pointsize)}
lines(c(26.5,26.9),c(-12.2,-12.2), lwd=2)
lines(c(26.5,26.5),c(-12.15,-12.25), lwd=2, lend=2)
lines(c(26.9,26.9),c(-12.15,-12.25), lwd=2, lend=2)
text(26.9,-12.2, "50 KM", pos=4)
box()
}
if(saving){
pdf(file=paste0(output_folder, "/Fig4_Spillovers.pdf"), width=12, height=4)
fig_spillovers()
dev.off()
}
saveRDS(vill, "Data/vill.RDS")
set.seed(1)
vill <- readRDS(file = "Data/vill.RDS")
df = vill
dv = "da109_not_verifiable"
cols <- c("TUUNGANE", "WEIGHT", "LOTT_BIN",
"IDV", "IDV_CDCCODE", "IDS_CDCCODE",
"CHIEF", "qr026i_fund_misuse", "res",
"da109_not_verifiable")
dat <- df[, intersect(names(df), cols)]
dat <- dat %>% arrange(LOTT_BIN)
#residuals of village-level obs in control
dat0 <- dat[dat$TUUNGANE == 0 & !is.na(dat[[dv]]),]
dat0$dv <- dat0[[dv]]
m <- lm(dv ~ TUUNGANE + as.factor(LOTT_BIN), data = dat0, weights = dat0$WEIGHT)
dat0$res <- m$residuals
# Declare Tuungane Design
design_tuungane <- function(ate){
#duplicate control data (note 1/3 outcomes missing for "da109_not_verifiable")
dat01 <- dat0
dat01$IDV <- paste0("dup", dat0$IDV)
dat <- rbind(dat01,dat0)
U <- declare_population(data = dat)
Y <- declare_potential_outcomes(
Y_Z_0 = res,
Y_Z_1 = ate + res
)
per_block <- as.data.frame(table(dat$LOTT_BIN))$Freq / 2
Z <- declare_assignment(blocks = LOTT_BIN, block_m = per_block)
R <- declare_reveal(Y, Z)
Q <- declare_estimand(ATE = mean(Y_Z_1 - Y_Z_0, na.rm = TRUE))
B <- declare_estimator(Y ~ Z, #weights = ipw,
estimand = Q,
model = lm_robust,
label = "tuungane_estimator")
design <- U + Y + Z + R  + Q + B #get_weights
return(design)
}
d1_fin_irreg <- design_tuungane(ate = 0)
ates = seq(0, .2, length = 7)
d1s <- redesign(d1_fin_irreg, ate = ates)
diagnoses1 <- diagnose_design(d1s, bootstrap_sims = 0)
mde_plot(diagnoses1, "Financial Irregularities", xlim = c(0,.2))
if(saving){
pdf(paste0(output_folder, "/Fig6_MDE_FinIrreg.pdf"), width = 5, height = 4)
mde_plot(diagnoses1, "Financial Irregularities", xlim = c(0,.2))
dev.off()
}
#join indiviual and village data
ABD <- left_join(ind, vill, by = intersect(names(ind), names(vill)) )
# household survey to village level
av10<-aggregate(av_10_gender ~ IDV, data=ABD, function(x) {sum(!is.na(x))}, na.action = NULL)
colnames(av10) <- c("IDV","av10")
ABD <- left_join(ABD, av10, by="IDV")
ABD$StepA <- ( !(ABD$a_3_date_village_entry=="") | !(ABD$ac_3_date=="") | !(ABD$am_3_ag_date=="") | ABD$av10>0)
# LLU visited
stepA_Total<-length(ABD$StepA[ABD$StepA==1 & ABD$vill==1])
stepA_Tuungane <-length(ABD$StepA[ABD$StepA==1 & ABD$vill==1 & ABD$TUUNGANE==1])
stepA_Control <-length(ABD$StepA[ABD$StepA==1 & ABD$vill==1 & ABD$TUUNGANE==0])
# Take the most complete variable of the Step A household survey: av_10_gender
stepA_HHs <- length(ABD$av_10_gender[!is.na(ABD$av_10_gender)])
stepA_HHs_Tuungane <- length(ABD$av_10_gender[!is.na(ABD$av_10_gender) & ABD$TUUNGANE==1])
stepA_HHs_Control <- length(ABD$av_10_gender[!is.na(ABD$av_10_gender) & ABD$TUUNGANE==0])
stepA_HHs
stepA_HHs_Tuungane
stepA_HHs_Control
ABD$StepB <- (!(ABD$b_3_date==""))
ABD %<>% group_by(IDV) %>% mutate(vill = row_number()) %>% ungroup()
# LLU visited
stepB_Total<-length(ABD$StepB[ABD$StepB==1 &  ABD$vill==1])
stepB_Tuungane<-length(ABD$StepB[ABD$StepB==1  & ABD$vill==1  & ABD$TUUNGANE==1])
stepB_Control<-length(ABD$StepB[ABD$StepB==1  & ABD$vill==1  & ABD$TUUNGANE==0])
stepB_Total
stepB_Tuungane
stepB_Control
# household survey to village level
q11<-aggregate(q011_sex ~ IDV, data=ABD, function(x) {sum(!is.na(x))}, na.action = NULL)
colnames(q11) <- c("IDV","q11")
ABD <- merge(ABD, q11, by="IDV", all=TRUE)
ABD$StepD <- (!(ABD$cq007_date=="") | ABD$q11>0)
# Total Step D
stepD_Total<-length(ABD$StepD[ABD$StepD==1 & ABD$vill==1])
stepD_TuuRapid <- length(ABD$StepD[ABD$StepD==1 & ABD$vill==1 & ABD$TUUNGANE==1 & ABD$IDS_RAPID==1])
stepD_TuuNotrapid <- length(ABD$StepD[ABD$StepD==1 & ABD$vill==1 & ABD$TUUNGANE==1 & ABD$IDS_RAPID==0])
stepD_ControlRapid <- length(ABD$StepD[ABD$StepD==1 & ABD$vill==1 & ABD$TUUNGANE==0 & ABD$IDS_RAPID==1])
stepD_ControlNotrapid <- length(ABD$StepD[ABD$StepD==1 & ABD$vill==1 & ABD$TUUNGANE==0 & ABD$IDS_RAPID==0])
# Missing LLUs by province
missD_TuuRapid<-table(ABD$StepD[ABD$vill==1 & ABD$IDS_RAPID==1 & ABD$TUUNGANE==1], ABD$IDS_DISTRICT[ABD$vill==1 & ABD$IDS_RAPID==1  & ABD$TUUNGANE==1])
missD_TuuNotrapid<-table(ABD$StepD[ABD$vill==1 & ABD$IDS_RAPID==0 & ABD$TUUNGANE==1], ABD$IDS_DISTRICT[ABD$vill==1 & ABD$IDS_RAPID==0  & ABD$TUUNGANE==1])
missD_ControlRapid<-table(ABD$StepD[ABD$vill==1 & ABD$IDS_RAPID==1 & ABD$TUUNGANE==0], ABD$IDS_DISTRICT[ABD$vill==1 & ABD$IDS_RAPID==1  & ABD$TUUNGANE==0])
missD_ControlNotrapid<-table(ABD$StepD[ABD$vill==1 & ABD$IDS_RAPID==0 & ABD$TUUNGANE==0], ABD$IDS_DISTRICT[ABD$vill==1 & ABD$IDS_RAPID==0  & ABD$TUUNGANE==0])
stepD_Total
stepD_TuuRapid
stepD_TuuNotrapid
stepD_ControlRapid
stepD_ControlNotrapid
missD_TuuRapid
missD_TuuNotrapid
missD_ControlRapid
missD_ControlNotrapid
# Take the most complete variable of the Step D household survey: q011_sex
stepD_Panel_Tuungane <- length(ABD$q011_sex[!is.na(ABD$q011_sex) & ABD$IDS_TYPES=="DMC" & ABD$TUUNGANE==1])
stepD_Panel_Control <- length(ABD$q011_sex[!is.na(ABD$q011_sex) & ABD$IDS_TYPES=="DMC" & ABD$TUUNGANE==0])
stepD_Panel_Tuungane
stepD_Panel_Control
# Take the most complete variable of the Step D household survey: q011_sex
stepD_HH_TuuRap <- length(ABD$q011_sex[!is.na(ABD$q011_sex) & ABD$IDS_TYPES=="DML" & ABD$TUUNGANE==1 & ABD$IDS_RAPID==1])
stepD_HH_TuuNotrapid <- length(ABD$q011_sex[!is.na(ABD$q011_sex) & ABD$IDS_TYPES=="DML" & ABD$TUUNGANE==1 & ABD$IDS_RAPID==0])
stepD_HH_ControlRap <- length(ABD$q011_sex[!is.na(ABD$q011_sex) & ABD$IDS_TYPES=="DML" & ABD$TUUNGANE==0 & ABD$IDS_RAPID==1])
stepD_HH_ControlNotrapid <- length(ABD$q011_sex[!is.na(ABD$q011_sex) & ABD$IDS_TYPES=="DML" & ABD$TUUNGANE==0 & ABD$IDS_RAPID==0])
stepD_HH_TuuRap
stepD_HH_TuuNotrapid
stepD_HH_ControlRap
stepD_HH_ControlNotrapid
# Take the most complete variable of the Step D household survey: q011_sex
info_TuuRap <- length(ABD$qi003_accept[!is.na(ABD$qi003_accept) & ABD$IDS_TYPES=="DML" & ABD$TUUNGANE==1 & ABD$IDS_RAPID==1])
info_TuuNotrapid <- length(ABD$qi003_accept[!is.na(ABD$qi003_accept) & ABD$IDS_TYPES=="DML" & ABD$TUUNGANE==1 & ABD$IDS_RAPID==0])
info_ControlRap <- length(ABD$qi003_accept[!is.na(ABD$qi003_accept) & ABD$IDS_TYPES=="DML" & ABD$TUUNGANE==0 & ABD$IDS_RAPID==1])
info_ControlNotrapid <- length(ABD$qi003_accept[!is.na(ABD$qi003_accept) & ABD$IDS_TYPES=="DML" & ABD$TUUNGANE==0 & ABD$IDS_RAPID==0])
info_TuuRap
info_TuuNotrapid
info_ControlRap
info_ControlNotrapid
#Average share of women in committee in control and treatment
vill %>% group_by(TUUNGANE) %>% summarize(share = mean(SHARE, na.rm = TRUE))
#External accountability mechanism present
mean(ABD_MERGE$DR_MECHANISMS_EXT, na.rm=T)
#External accountability mechanism present and required to report to community
mean(ABD_MERGE$DR_MECHANISMS_COMM, na.rm=T)
#Accounting form present upon arrival of enumerators team
mean(vill$da027_got_accounting_form, na.rm=T)
#Funds accounted for RAPID committee
mean(vill$ACCOUNTED_COMM, na.rm=T)
#Funds accounted for adit teams
mean(vill$ACCOUNTED_EVAL, na.rm=T)
#Share of funds justified
mean(vill$PART_JUSTIFIED, na.rm=T)
#Share of funds credibly justified
mean(vill$PART_CREDIBLY_JUSTIFIED, na.rm=T)
#General pop guessed correct grant amount
mean(ind$qr002CORRECT[!ind$CHIEF & ind$TUUNGANE==1], na.rm=TRUE)
#Willing to seek information among control
table(ind$qi003_accept[ind$TUUNGANE==0])
#Why refused to seek information
table(ind$qi004_why_not_accept[ind$qi003_accept==0&ind$TUUNGANE==0])
#Committed elected
mean(vill$ELECTIONS1[vill$IDV_RAPID==1])
#Committee elected, lott or concensus
mean(vill$ELECTIONS_LOTT_CON1[vill$TUUNGANE==1], na.rm=TRUE)
#Project through election
mean(vill$ELECTIONS2[vill$IDV_RAPID==1])
mean(vill$ELECTIONS_LOTT_CON2[vill$TUUNGANE==1], na.rm=TRUE)
#Spillover 5km
table(gps$TUUNGANE, gps$indirect05)
v <- !is.na(gps$gps_weight05); sum(v)
table(gps$TUUNGANE[v], gps$indirect05[v])
#Spillover 20km
table(gps$TUUNGANE, gps$indirect20)
v <- !is.na(gps$gps_weight20); sum(v)
table(gps$TUUNGANE[v], gps$indirect20[v])
#Spillover both
sum(!is.na(gps$gps_weight20)&!is.na(gps$gps_weight05))
head(dir)
dir[1:10, 1:10]
dim(dir)
test <- cbind(gps$CDCCODE, dir, 1:10)
test[1:20,]
test[1:20,1:20]
test <- cbind(gps$CDCCODE, gps$LOTT_BIN, dir[, 1:10])
test[1:20,1:20]
test[1:20,]
test[1:30,]
test[1:60,]
test[1:310,]
test[1:31,]
test[1:30,]
apply(test[1:30, -(1:2), 2, mean]
apply(test[1:30, -(1:2)], 2, mean)
dim(dir)
w05
w20
w05  <- sapply(1:spilloversims, function(j) gen_weight05(D=dir[,j], I=ind05[,j], data = gps))
dim(w05)
w05[1:10, 1:10]
w20  <- sapply(1:spilloversims, function(j) gen_weight05(D=dir[,j], I=ind20[,j], data = gps))
dir[1:10, 1:10]
ind05[1:10, 1:10]
ind30[1:10, 1:10]
ind20[1:10, 1:10]
gps[1:10, 1:10]
dim(gps)
gps[1:20. -(1:1020)]
gps[1:20, -(1:1020)]
gps[1, 1:10]
gps3 <- select(gps, -starts_with("dist_"))
dim(gps3)
head(gps3)
gps <- select(gps, -starts_with("dist_")) %>% select(gps, -c("latitude", "longitude"))
write_rds(list(gps, dir, ind05, ind20, w05, w20), "Data/gps_masked/spillover_data.rds")
gps <- select(gps, -starts_with("dist_")) %>% select(-c("latitude", "longitude"))
library(tidyverse)
write_rds(list(gps, dir, ind05, ind20, w05, w20), "Data/gps_masked/spillover_data.rds")
CONTENT05
ri.analysis <- function(Y,
DIR       = gps$TUUNGANE,
directs   = dir,
IND       = gps$indirect05,
indirects = ind05,
weight    = gps$gps_weight05,
weight_matrix,
spilloversims = 10,
blocks    = NULL){
real          <- gps.analysis(Y, DIR = DIR, IND = IND, weight = weight, coef = TRUE, blocks = blocks)
tstats05      <- sapply(1:spilloversims,
function(i) test.stats(i = i, Y = Y,
directs = directs,
indirects = indirects,
blocks = blocks,
weight_matrix = weight_matrix))
out <- c(real[[1]][1,], real[[1]][2,], real[[2]], "MSE(p)"=mean(tstats05 <= real[[2]]), real[[3]])
names(out) <- c("d", "se_d", "in", "se_in", "RMSE", "p", "N")
return(out)
}
dim(w05)
spilloversims
analysis05t <- sapply(gpsvars, function(j)
ri.analysis(gps[j][[1]], IND = gps$indirect05, indirects=ind05, weight = gps$gps_weight05, weight_matrix = w05, spilloversims = spilloversims)
)
ri.analysis
# Test statistic is the meas square error (actually, sqrt of this)
gps.analysis <- function(Y,
DIR = gps$TUUNGANE,
IND = gps$indirect05,
weight = gps$gps_weight05,
coef = FALSE,               #If TRUE return the coefficients, if false just return the MSE
blocks = gps$LOTT_BIN){
.dir <- DIR - mean(DIR, na.rm = TRUE)
.ind <- IND - mean(IND, na.rm = TRUE)
.int <- .dir*.ind
if(is.null(blocks))  M   <- summary(lm(Y ~ .dir + .ind + .int, weight = weight))
if(!is.null(blocks)) M   <- summary(lm(Y ~ .dir + .ind + .int + as.factor(blocks), weight = weight))
if(coef)  out <- list(coef(M)[2:3, 1:2], sqrt(mean(M$residuals^2)),  length(M$residuals))
if(!coef) out <- sqrt(mean(M$residuals^2))    # MSE CALCULATION
return(out)
}
# Get the MSE for assignment i: Note that weights need to be produced for each assignment
test.stats  <- function(i,
Y,
directs=dir,
indirects=ind05,
blocks = gps$LOTT_BIN,
weight_matrix){
diri <- directs[,i]
indi <- indirects[,i]
wi   <- weight_matrix[,i]
gps.analysis(Y, DIR = diri, IND = indi, weight = wi, blocks = blocks, coef = FALSE)
}
## Randomization Inference Analysis Function
ri.analysis <- function(Y,
DIR       = gps$TUUNGANE,
directs   = dir,
IND       = gps$indirect05,
indirects = ind05,
weight    = gps$gps_weight05,
weight_matrix,
spilloversims = 10,
blocks    = NULL){
real          <- gps.analysis(Y, DIR = DIR, IND = IND, weight = weight, coef = TRUE, blocks = blocks)
tstats05      <- sapply(1:spilloversims,
function(i) test.stats(i = i, Y = Y,
directs = directs,
indirects = indirects,
blocks = blocks,
weight_matrix = weight_matrix))
out <- c(real[[1]][1,], real[[1]][2,], real[[2]], "MSE(p)"=mean(tstats05 <= real[[2]]), real[[3]])
names(out) <- c("d", "se_d", "in", "se_in", "RMSE", "p", "N")
return(out)
}
## END ##
analysis05t <- sapply(gpsvars, function(j)
ri.analysis(gps[j][[1]], IND = gps$indirect05, indirects=ind05, weight = gps$gps_weight05, weight_matrix = w05, spilloversims = spilloversims)
)
t(analysis05t)
t(round(analysis05t, 2))
masked_gps <- read_rds("Data/gps_masked/spillover_data.rds")
names(masked_gps)
is.list(masked_gps)
masked_gps[[1]]
write_rds(list(gps = gps, dir = dir, ind05, ind20, w05, w20), "Data/gps_masked/spillover_data.rds")
masked_gps <- read_rds("Data/gps_masked/spillover_data.rds")
names(masked_gps)
write_rds(list(gps = gps, dir = dir, ind05 = ind05, ind20 = ind20, w05 = w05, w20 = w20), "Data/gps_masked/spillover_data.rds")
masked_gps <- read_rds("Data/gps_masked/spillover_data.rds")
gps   <- masked_gps$gps
dir   <- masked_gps$dir
ind05 <- masked_gps$ind05
ind20 <- masked_gps$ind20
w05   <- masked_gps$w05
w20   <- masked_gps$w20
w20[1:10, 1:10]
w05[1:10, 1:10]
w20  <- sapply(1:spilloversims, function(j) gen_weight20(D=dir[,j], I=ind20[,j], data = gps))
if(save_geodeidentified_data) write_rds(list(gps = gps, dir = dir, ind05 = ind05, ind20 = ind20, w05 = w05, w20 = w20), "Data/gps_masked/spillover_data.rds")
write_rds(list(gps = gps, dir = dir, ind05 = ind05, ind20 = ind20, w05 = w05, w20 = w20), "Data/gps_masked/spillover_data.rds")
analysis20 <- sapply(gpsvars, function(j)
ri.analysis(gps[j][[1]], IND = gps$indirect20, indirects=ind20, weight = gps$gps_weight20, weight_matrix = w20, spilloversims = spilloversims)
)
CONTENT20 <- round(t(analysis20),2)
kable(CONTENT05, title = "Spillovers at 5km")
CONTENT20
