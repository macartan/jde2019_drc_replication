# Make a village level dataset

villmeans <- cdcdata

# This function takes a default dataset `villmeans` and adds in aggregated .outcome data from .data
add.villmean <- function(.data, .outcome, vdata = villmeans, newname = NULL) {
  if(!is.null(newname)) {names(.data)[names(.data) == .outcome] <- newname; .outcome <- newname}
  D2 <- aggregate(.data[c("IDV", .outcome)], by=list(.data$IDV), FUN="mean", na.rm=TRUE)
  out <- merge(vdata, D2, by.x = "IDV", by.y = "IDV", all.x = TRUE)
  out <- subset(out, select = -c(Group.1))
  return <- out     
}

# CAPTURE
villmeans <- add.villmean(.data = vill, .outcome = "da109_not_verifiable")
head(villmeans)

villmeans <- add.villmean(.data = ind, .outcome = "qr026i_fund_misuse")
head(villmeans)
dim(villmeans)

villmeans <- add.villmean(.data = ind[ind$RA==1,], .outcome = "qr2830_list_experiment", newname ="LIST_RA_1")
villmeans <- add.villmean(.data = ind[ind$RA==0,], .outcome = "qr2830_list_experiment", newname ="LIST_RA_0")

# Clean up interactions -- Impute means where one side has data present
villmeans <- within(villmeans, LIST_RA_1[is.na(LIST_RA_1) & !is.na(LIST_RA_0)] <- mean(LIST_RA_1, na.rm = TRUE))
villmeans <- within(villmeans, LIST_RA_0[is.na(LIST_RA_0) & !is.na(LIST_RA_1)] <- mean(LIST_RA_0, na.rm = TRUE))
villmeans$LIST_RA <- villmeans$LIST_RA_1 - villmeans$LIST_RA_0
villmeans <- subset(villmeans, select = -c(LIST_RA_1,LIST_RA_0))

# villmeans <- add.villmean(.data = ABD_INDIV_PROP, .outcome = "proportion_benef")  
villmeans <- add.villmean(.data = vill, .outcome = "stdev_benefits")
villmeans <- add.villmean(.data = ind[ind$CHIEF==1,], .outcome = "Correct_D_projet", newname ="Right1_Chief")
villmeans <- add.villmean(.data = ind[ind$CHIEF==0,], .outcome = "Correct_D_projet", newname ="Right1_Civ")

# INTERACTIONS
villmeans <- within(villmeans, Right1_Chief[is.na(Right1_Chief) & !is.na(Right1_Civ)] <- mean(Right1_Chief, na.rm = TRUE))
villmeans <- within(villmeans, Right1_Civ[is.na(Right1_Civ) & !is.na(Right1_Chief)] <- mean(Right1_Civ, na.rm = TRUE))

villmeans$Right1 <- villmeans$Right1_Civ - villmeans$Right1_Chief
villmeans <- subset(villmeans, select = -c(Right1_Civ,Right1_Chief))

# MECHANISMS
villmeans <- add.villmean(.data = vill, .outcome = "PART_A1")
villmeans <- add.villmean(.data = vill, .outcome = "N_INTERV")
villmeans <- add.villmean(.data = vill, .outcome = "MALE_DOM")
villmeans <- add.villmean(.data = vill, .outcome = "MFI_SELECTION")
villmeans <- add.villmean(.data = vill,  .outcome = "MFI_COMPOSITION")
villmeans <- add.villmean(.data = vill, .outcome = "MFI_MECHANISMS")
villmeans <- add.villmean(.data = ind, .outcome = "MFI_COMPLAINTS")
villmeans <- add.villmean(.data  = ind, .outcome = "qr002CORRECT")
villmeans <- add.villmean(.data = ind, .outcome = "qi003_accept")
villmeans <- add.villmean(.data = vill, .outcome = "MFI_ACCOUNTING")


dim(villmeans)
head(villmeans)
summary(villmeans)  
summary(villmeans[villmeans$RAPID==1,])  

####################################################################################################



# get data
cdcdata$LOTT_BIN <- unclass(factor(cdcdata$LOTT_BIN))

# extract adjacency matrix. Note that this is 1020 * 1020: there are 100 obs with no geo data
adj <- idv_dists[,4:ncol(idv_dists)]
dim(adj)

# Add in treatment data
# gps <- idv_dists[,-3]
gps <- GPS[,-3] #old code
gps <- merge(gps, cdcdata, by = "IDV")

# Rerandomize -- same # treated CDC in lottbin (ie conditional on geographic data availability)
cdc_level_data <- aggregate(x = gps[,c("TUUNGANE", "CDCCODE", "LOTT_BIN")], by = list(gps$CDCCODE), FUN = "mean")
resample       <- function() ave(cdc_level_data$TUUNGANE, cdc_level_data$LOTT_BIN, FUN = function(x)  sample(x))
rerand         <- function(){
  resampled <- cdc_level_data$CDCCODE[resample()==1]
  as.vector(gps$CDCCODE %in% resampled)
}

# Save in indirect measures
gps$indirect05  <- 1*indirect(d=5)
gps$indirect20 <- 1*indirect(d=20)

# Now get matrices of re-randomized exposure within some distance like this:
dir    <- replicate(spilloversims, rerand())
ind05  <- sapply(1:spilloversims, function(j) indirect(d = 5, treated = dir[,j]))
ind20  <- sapply(1:spilloversims, function(j) indirect(d = 20, treated = dir[,j]))

# 5km
# Back out probabilities and weights
gps$pDI_05  <- apply(dir     * ind05,     1, mean)
gps$pD0_05  <- apply(dir     * (1-ind05), 1, mean)
gps$p0I_05  <- apply((1-dir) * ind05,     1, mean)
gps$p00_05  <- apply((1-dir) * (1-ind05), 1, mean)

# Inverse weights
gps %<>%     dplyr::mutate(
  wDI_05  = 1/pDI_05,
  wD0_05  = 1/pD0_05,
  w0I_05  = 1/p0I_05,
  w00_05  = 1/p00_05
)

# 20km
# Back out probabilities and weights
gps$pDI_20  <- apply(dir     * ind20,     1, mean)
gps$pD0_20  <- apply(dir     * (1-ind20), 1, mean)
gps$p0I_20  <- apply((1-dir) * ind20,     1, mean)
gps$p00_20  <- apply((1-dir) * (1-ind20), 1, mean)

# Inverse weights
gps %<>%     dplyr::mutate(
  wDI_20  = 1/pDI_20,
  wD0_20  = 1/pD0_20,
  w0I_20  = 1/p0I_20,
  w00_20  = 1/p00_20
)

# Cleanup
# For full analysis there should only be cases that have a 0<p<1  probability of being in all conditions
gps %<>%     dplyr::mutate( 
  exclude05 = (pDI_05 ==1 | pDI_05 ==0) | (pD0_05 ==1 | pD0_05 ==0) | (p0I_05 ==1 | p0I_05 ==0) |(p00_05 ==1 | p00_05 ==0),
  exclude20 = (pDI_20 ==1 | pDI_20 ==0) | (pD0_20 ==1 | pD0_20 ==0) | (p0I_20 ==1 | p0I_20 ==0) |(p00_20 ==1 | p00_20 ==0)
)

# set weights to NA for excluded cases
# set weights to NA for excluded cases
gps$wDI_05[gps$exclude05] <- NA; gps$w0I_05[gps$exclude05] <- NA; gps$wD0_05[gps$exclude05] <- NA; gps$w00_05[gps$exclude05] <- NA
gps$wDI_20[gps$exclude20] <- NA; gps$w0I_20[gps$exclude20] <- NA; gps$wD0_20[gps$exclude20] <- NA; gps$w00_20[gps$exclude20] <- NA

gps$gps_weight05 <- gen_weight05(D=gps$TUUNGANE, I=gps$indirect05, data = gps)
gps$gps_weight20 <- gen_weight20(D=gps$TUUNGANE, I=gps$indirect20, data = gps)

