---
title: 'Institutional Change by Imitation: Demonstrating the Practice of Democracy in Congolese Villages'
author: "Authors: Anonymous"
date: "July 2, 2018"
output:
  html_document:
    number_sections: yes
    theme: united
    toc: yes
    toc_depth: 3
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 3
---

```{r setup, include=FALSE}
rm(list=ls(all=TRUE)) 
gc()
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

This .Rmd file replicates the core analysis as well as additional results. Data can be found online.^[Data available online: https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/BSASJR] Analyses are run directly from the website or locally from datafolder "Data". Supporting code can be found in folder "Code". The code outputs tables and figures into the folder "Output", which are then sourced in from the Latex file.

# Replication Setup

```{r, include = FALSE}

# Load (and install when necessary) packages

library("pacman")
pacman::p_load(rgdal,raster,plyr,AER,devtools,doBy,dplyr,energy,entropy,foreign,gdata,ggplot2,ggthemes,grid,gridExtra,haven,ivpack,lmtest,magrittr,maps,maptools,mosaic,multiwayvcov,pander,parallel,plm,R.matlab,reshape2,sandwich,SDMTools,spdep,stargazer,tidyr,xtable,SDMTools, estimatr, knitr,readstata13)

# List indicators of main outcome (capture)

capture_var_names <- c(
  "Financial Irregularities",
  "Embezzlement (direct)",
  "Embezzlement (list experiment)",
  "Inequality of (Private) Benefits",
  "Dominance of Chief's Preferences")

# List indicators of mechanisms (participation, accountability, transparency, efficiency)

mech_var_names = c(
  "Meeting Attendance",
  "Interventions in Meeting",
  "Dominance of Men in Discussion",
  "Participatory Selection Methods",
  "Committee Composition",
  "Accountability Mechanisms", 
  "Private Complaints", 
  "Knowledge of Project Amount",
  "Willingness to Seek Information",
  "Quality of Accounting",
  "Information Transmission")

varnames <- c(capture_var_names, mech_var_names)
varnames2 <- paste(rbind(varnames, rep("",length(varnames))))

# Run helper files
source("Code/1.1 Helpers.R")
source("Code/1.2 Analysis Helpers.R")
source("Code/1.3 Prog_MFI.R")
source("Code/1.4 Prog_matplot.R")
source("Code/1.5 output helpers.R")

```

## Options

```{r, include =FALSE}

# Set number sims used for calculating propensities and for the ri
spilloversims <- 10 

# Indicate whether data is run locally or from the internet

```


```{r, include = TRUE}
# Prepare the datasets for analyses
source("Code/2.1 PrepDatasets.R")

# Prepare variables for analyses
source("Code/2.2.1 PrepMeasuresCapture.R")
source("Code/2.2.2 PrepMeasuresParticipation.R")
source("Code/2.2.3 PrepMeasuresAccountability.R")
source("Code/2.2.4 PrepMeasuresTransparency.R")
source("Code/2.2.5 PrepMeasuresEfficiency.R")
```

# Table 5: Balance Table (TUUNGANE)

```{r, include = FALSE}
source("Code/3.1 Prep Data for Balance Tests.R")
```

```{r}
# Function to report mean in two groups and standardized difference -----------
balance_function <- function(Y,X,W = rep(1, length(X))){
  
  K <- (!is.na(Y[X==0]) & !is.na(W[X==0]))
  c(
    weighted.mean(Y[X==0], W[X==0], na.rm = TRUE),
    weighted.mean(Y[X==1], W[X==1], na.rm = TRUE),
    (weighted.mean(Y[X==1], W[X==1], na.rm = TRUE) - weighted.mean(Y[X==0], W[X==0], na.rm = TRUE))/
      (wt.sd(Y[X==0][K], W[X==0][K])),
    sum(!is.na(Y[X==1 | X==0]))
  )}

# Balance variables --------------------------------------------------
BALANCE_VARS <- c(DIST   = "distance",
                  VILL   = "mineral_index",
                  PUBLIC = "public2006",
                  VILL   = "former_chief_elec",
                  MIG    = "mig2006",  
                  STATS  = "age"
                  # VILL   = "casserite",
                  # VILL   = "cobalt",
                  # VILL   = "coltan",
                  # VILL   = "copper",
                  # VILL   = "gold"
                  )

# Balance datasets ---------------------------------------------------
BALANCE      <- lapply(list(DIST, VILL, PUBLIC, VILL, MIG,  STATS),
                   merge, select(ABD_VILL, IDV, TUUNGANE, PWEIGHT2),  by = "IDV")

# Balance table -------------------------------------------------------
balance.table <- sapply(1:length(BALANCE),
                        function(i){
                          data <- BALANCE[[i]]
                          Y    <- BALANCE_VARS[i]
                          balance_function(data[,Y][],
                                           data[,"TUUNGANE"][], 
                                           data[,"PWEIGHT2"][])}) %>% 
                  round(., 2) %>% 
                  t()
              
```

```{r, include = FALSE}
source("Code/3.2 Format Balance Tests.R")
```

# Table 3: Main results

```{r}
main_results <- list(
      
fin_irregul  =  lm_robust(as.formula("da109_not_verifiable ~ TUUNGANE"),
                          data     =  D_AUDIT_NOTVERI, 
                          weights  = WEIGHT),

embezzl_dir  = lm_robust(as.Formula("qr026i_fund_misuse ~ TUUNGANE"),
                          data     = ABD_INDIV_DIRECT, 
                          weights  = WEIGHT, 
                          clusters = IDS_CDCCODE ),

embezzl_list = lm_robust(as.formula("qr2729_list_experiment  ~ TUUNGANE + RA + RA*TUUNGANE"), 
                          data     = ABD_INDIV_LIST,
                          weights  = WEIGHT,
                          clusters = IDS_CDCCODE),

ineq_benef   = lm_robust(as.formula("stdev_benefits ~ TUUNGANE"), 
                          data     = ABD_INDIV_BEN,
                          weights  = WEIGHT ),

chief_domin  = lm_robust(as.formula("Correct_D_projet ~ TUUNGANE + CHIEF + CHIEF*TUUNGANE"), 
                          data     = CHIEF_DOM,
                          clusters = IDS_CDCCODE,
                          weights  = WEIGHT))


main_table <- mapply(function(x, name)  { 
                tidy = tidy.lm_robust(x); rownames(tidy) = tidy$term;
                
               if( name ==  "embezzl_list" | name == "chief_domin" ) 
                 round(c(Control   = tidy[3, "estimate"],  
                         Effect    = tidy[4, "estimate"],  
                         std_error = tidy[4, "std.error"],
                         N         = x$N), 3)
                else
                 round(c(Control  = tidy["(Intercept)", "estimate"],
                        Effect    = tidy["TUUNGANE", "estimate"], 
                        std_error = tidy["TUUNGANE", "std.error"], 
                        N         = x$N ),3)
                
                }, main_results, names(main_results))

kable(t(main_table))
```

```{r, include=FALSE}
source("Code/4.1 MainResults.R")
```

# Table 4: Mechanisms

```{r}
mechanisms <- list(
  part  =  lm_robust(as.formula("PART_A1   ~ TUUNGANE"),
                     data = ABD_VILL_ATTEND_7, weights = WEIGHT),
 inter =  lm_robust(as.formula("N_INTERV  ~ TUUNGANE"),
                    data = AB_DISC, weights = WEIGHT),
 male_d = lm_robust(as.formula("MALE_DOM  ~ TUUNGANE"),
                    data = AB_DISC, weights = WEIGHT),
 sel    = lm_robust(as.formula("MFI_SELECTION ~ TUUNGANE"),
                    data = ABD_VILL_SEL, weights = WEIGHT),
 compos = lm_robust(as.formula("MFI_COMPOSITION ~ TUUNGANE"),
                    data = ABD_VILL_1, weights = WEIGHT),
 mech   = lm_robust(as.formula("MFI_MECHANISMS  ~ TUUNGANE"),
                    data  = ABD_MERGE, weights = WEIGHT),
 compl = lm_robust(as.formula("MFI_COMPLAINTS ~ TUUNGANE"),
                   data =  ABD_INDIV_COMPLAINTS, weights = WEIGHT, clusters = IDS_CDCCODE ),
 corr  = lm_robust(as.formula("qr002CORRECT   ~ TUUNGANE"),
                   data =  ABD_INDIV_KNOWS, weights = WEIGHT, clusters = IDS_CDCCODE ),
 accep = lm_robust(as.formula("qi003_accept  ~ TUUNGANE"),
                   data =  ABD_INDIV_SEEKS, weights = WEIGHT, clusters = IDS_CDCCODE ),
 accoun = lm_robust(as.formula("MFI_ACCOUNTING ~ TUUNGANE"),
                    data  = D_AUDIT_ACCOUNT, weights = WEIGHT),
 transm = lm_robust(as.formula("SUM_HEALTH_INFO ~ TUUNGANE + IDS_RAPID + IDS_RAPID*TUUNGANE"),
                    data = ABD_INDIV_HEALTH, weights = WEIGHT, clusters = IDS_CDCCODE))

mechanisms_table <- mapply(function(x, name){ 
                    tidy = tidy.lm_robust(x); rownames(tidy) = tidy$term;
                   if( name ==  "transm" ) 
                     round(c(Control   = tidy["IDS_RAPID",           "estimate"],  
                             Effect    = tidy["TUUNGANE:IDS_RAPID",  "estimate"],  
                             std_error = tidy["TUUNGANE:IDS_RAPID", "std.error"],
                             N         = x$N), 3)
                    else
                     round(c(Control  = tidy["(Intercept)", "estimate"],
                            Effect    = tidy["TUUNGANE", "estimate"], 
                            std_error = tidy["TUUNGANE", "std.error"], 
                            N         = x$N ),3)
                    
                    }, mechanisms, names(mechanisms))

kable(t(mechanisms_table))
```


# Tables X and X: Robustness and heterogeneity

```{r, include = TRUE}
source("Code/4.2 RobustResults.R")
```


# Table 6: Summary statistis

```{r, include = TRUE, eval = FALSE}

y <- c("RAPID", "TUUNGANE", "da109_not_verifiable", "qr026i_fund_misuse",
       "qr2729_list_experiment","stdev_benefits", "Correct_D_projet",
       "PART_A1", "N_INTERV", "MALE_DOM", "MFI_SELECTION", "MFI_COMPOSITION", 
       "MFI_MECHANISMS","MFI_COMPLAINTS", "qr002CORRECT", "qi003_accept", 
       "MFI_ACCOUNTING", "SUM_HEALTH_INFO")

d <- list(ABD_VILL, ABD_VILL, D_AUDIT_NOTVERI, 
          ABD_INDIV_DIRECT,ABD_INDIV_LIST,ABD_INDIV_BEN,
          CHIEF_DOM, ABD_VILL_ATTEND_7, AB_DISC,  AB_DISC,
          ABD_VILL_SEL, ABD_VILL_1,  ABD_MERGE,ABD_INDIV_COMPLAINTS,                         ABD_INDIV_KNOWS, ABD_INDIV_SEEKS, D_AUDIT_ACCOUNT, ABD_INDIV_HEALTH)


mapply(function(y, d){
  x <- d[, y][]
  c(length(x), mean(x, na.rm = TRUE), sd(x, na.rm = TRUE) , min(x), max(x))
},y, d)
source("Code/5 SumStats.R")

```

# Tables 7 and 8: Spillovers

```{r, echo=FALSE}
source("Code/7.1 Prep Spillovers.R")
```

```{r, include = TRUE}
gps.analysis <- function(Y, DIR = gps$TUUNGANE, IND = gps$indirect05,
                         weight = gps$gps_weight05, coef = FALSE, blocks = gps$LOTT_BIN){
  .dir <- DIR - mean(DIR, na.rm = TRUE)   
  .ind <- IND - mean(IND, na.rm = TRUE)   
  .int <- .dir*.ind
  if(is.null(blocks))  M   <- summary(lm(Y ~ .dir + .ind + .int, weight = weight))
  if(!is.null(blocks)) M   <- summary(lm(Y ~ .dir + .ind + .int + as.factor(blocks), weight = weight))
  if(coef)  out <- list(coef(M)[2:3, 1:2], mean(M$residuals^2),  length(M$residuals))
  if(!coef) out <- mean(M$residuals^2)    # MSE CALCULATION
  return(out)
}

test.stats  <- function(i, Y, directs=dir, indirects=ind05,
                        blocks = gps$LOTT_BIN, f_w = gen_weight05){
  diri <- directs[,i]
  indi <- indirects[,i]
  wi   <- f_w(diri, indi)
  gps.analysis(Y, DIR = diri, IND = indi, weight = wi, blocks = blocks, coef = FALSE)
}

ri.analysis <- function(Y, 
                       DIR = gps$TUUNGANE,   
                       directs=dir,     
                       blocks = gps$LOTT_BIN,
                       IND = gps$indirect05, 
                       indirects=ind05, 
                       weight = gps$gps_weight05, 
                       f_w = gen_weight05, 
                       spilloversims = 10){
  real          <- gps.analysis(Y, DIR = DIR, IND = IND, weight = weight, coef = TRUE, blocks = blocks)
  tstats05      <- sapply(1:spilloversims,
                          function(i) test.stats(i = i, Y = Y,
                                                 directs = directs, indirects = indirects,
                                                 blocks = blocks, f_w = f_w))
  out <- c(real[[1]][1,], real[[1]][2,], real[[2]], "MSE(p)"=mean(tstats05 <= real[[2]]), real[[3]])
  names(out) <- c("d", "se_d", "in", "se_in", "MSE", "p", "N")
  return(out)
}

# Generate village level data
villmeans2 <- villmeans[,c(1, 8:23)]
gpsvars    <- names(villmeans2)[-1] 
gps <- merge(gps, villmeans2, by = "IDV", all.x = TRUE)

analysis05 <- sapply(gpsvars, function(j) ri.analysis(gps[j][[1]], IND = gps$indirect05, indirects=ind05, weight = gps$gps_weight05, f_w = gen_weight05, spilloversims = spilloversims))
CONTENT05 <- round(t(analysis05),2)

analysis20 <- sapply(gpsvars, function(j) ri.analysis(gps[j][[1]], IND = gps$indirect20, indirects=ind20, weight = gps$gps_weight20, f_w = gen_weight20, spilloversims = spilloversims))
CONTENT20 <- round(t(analysis20),2)

kable(CONTENT05, title = "Spillovers at 5km")
kable(CONTENT20, title = "Spillovers at 20km")
```

```{r, echo=FALSE}
source("Code/7 Spillovers.R")
```

# Table 9: Social desirability

```{r, include = TRUE}
source("Code/6 SocDesirability.R")
```

# Figure 1: Tuungane Map

```{r}
#load shapefiles
col <- readOGR("Data/shapefiles", "collectivite")

#load Tuungane GIS files
gps <- read.dta13("Data/gps/gps_tuungane.dta")
coordinates(gps) <- gps[,c("longitude","latitude")]
proj4string(gps) <- CRS("+init=epsg:4326")

col <- spTransform(col, CRSobj = CRS(proj4string(gps)))

#generate plot
xlim <- gps@bbox[1,] + c(3, 0)
ylim <- gps@bbox[2,] + c(-1, 1)

map_tuungane <- function(){
  par(mar = c(0.5, 0.5, 0.5, 0.5))
  plot(col, xlim = xlim, ylim = ylim, lwd = .1)
  plot(gps, add=TRUE, pch = c(1,16)[factor(gps$TUUNGANE)], cex = .4, lwd = .7)
  box()
  scalebar(200, xy = c(30, -11.5), type = "bar", below = "km", lwd = 3, divs = 3, cex = .8)
  legend(29.6, -9, legend=c("Tuungane", "Control"),
         pch = c(16, 1), bty = "n",
         cex = .8, pt.cex = 1.2, text.width = 1.5, y.intersp = 1, x.intersp = .8, inset=0.05)
}

map_tuungane()

pdf("Output/Fig_Tuungane_chefferies.pdf", width = 3, height = 5)
map_tuungane()
dev.off()

```

# Figure 3: Timeline

```{r, include = TRUE}
source("Code/10 Fig_Timeline.R")
fig_timeline()
```

# Figure 4: Main effects

```{r, echo=FALSE}
source("Code/8 Fig_Effects.R")
fig_main()
```

# Figure 5: Mechanisms

```{r, echo=FALSE}
fig_mechanisms()
```

# Figure 6: Spillovers

```{r, include = TRUE}
source("Code/9 Fig_Spillovers.R")
fig_spillovers()
```
