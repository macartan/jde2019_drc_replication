
# Make a village level dataset

villmeans <- cdcdata
head(villmeans)

add.villmean <- function(.data, .outcome, vdata = villmeans, newname = NULL) {
  if(!is.null(newname)) {names(.data)[names(.data) == .outcome] <- newname; .outcome <- newname}
  D2 <- aggregate(.data[c("IDV", .outcome)], by=list(.data$IDV), FUN="mean", na.rm=TRUE)
  out <- merge(vdata, D2, by.x = "IDV", by.y = "IDV", all.x = TRUE)
  out <- subset(out, select = -c(Group.1))
  return <- out     
  }

# CAPTURE
villmeans <- add.villmean(.data = D_AUDIT_NOTVERI, .outcome = "da109_not_verifiable")
head(villmeans)

villmeans <- add.villmean(.data = ABD_INDIV_DIRECT, .outcome = "qr026i_fund_misuse")
head(villmeans)
dim(villmeans)

villmeans <- add.villmean(.data = ABD_INDIV_LIST[ABD_INDIV_LIST$RA==1,], .outcome = "qr2729_list_experiment", newname ="LIST_RA_1")
villmeans <- add.villmean(.data = ABD_INDIV_LIST[ABD_INDIV_LIST$RA==0,], .outcome = "qr2729_list_experiment", newname ="LIST_RA_0")

# Clean up interactions -- Impute means where one side has data present
villmeans <- within(villmeans, LIST_RA_1[is.na(LIST_RA_1) & !is.na(LIST_RA_0)] <- mean(LIST_RA_1, na.rm = TRUE))
villmeans <- within(villmeans, LIST_RA_0[is.na(LIST_RA_0) & !is.na(LIST_RA_1)] <- mean(LIST_RA_0, na.rm = TRUE))
villmeans$LIST_RA <- villmeans$LIST_RA_1 - villmeans$LIST_RA_0
villmeans <- subset(villmeans, select = -c(LIST_RA_1,LIST_RA_0))

# villmeans <- add.villmean(.data = ABD_INDIV_PROP, .outcome = "proportion_benef")  
villmeans <- add.villmean(.data = ABD_INDIV_BEN, .outcome = "stdev_benefits")

villmeans <- add.villmean(.data = CHIEF_DOM[CHIEF_DOM$CHIEF==1,], .outcome = "Correct_D_projet", newname ="Right1_Chief")
villmeans <- add.villmean(.data = CHIEF_DOM[CHIEF_DOM$CHIEF==0,], .outcome = "Correct_D_projet", newname ="Right1_Civ")
  # INTERACTIONS
  villmeans <- within(villmeans, Right1_Chief[is.na(Right1_Chief) & !is.na(Right1_Civ)] <- mean(Right1_Chief, na.rm = TRUE))
  villmeans <- within(villmeans, Right1_Civ[is.na(Right1_Civ) & !is.na(Right1_Chief)] <- mean(Right1_Civ, na.rm = TRUE))
  
villmeans$Right1 <- villmeans$Right1_Civ - villmeans$Right1_Chief
villmeans <- subset(villmeans, select = -c(Right1_Civ,Right1_Chief))



# MECHANISMS
villmeans <- add.villmean(.data = ABD_VILL_ATTEND_7, .outcome = "PART_A1")
villmeans <- add.villmean(.data = AB_DISC, .outcome = "N_INTERV")
villmeans <- add.villmean(.data = AB_DISC, .outcome = "MALE_DOM")
villmeans <- add.villmean(.data = ABD_VILL_SEL, .outcome = "MFI_SELECTION")
villmeans <- add.villmean(.data = ABD_VILL_1,  .outcome = "MFI_COMPOSITION")
villmeans <- add.villmean(.data = ABD_MERGE, .outcome = "MFI_MECHANISMS")
villmeans <- add.villmean(.data = ABD_INDIV_COMPLAINTS, .outcome = "MFI_COMPLAINTS")
villmeans <- add.villmean(.data  = ABD_INDIV_KNOWS, .outcome = "qr002CORRECT")
villmeans <- add.villmean(.data = ABD_INDIV_SEEKS, .outcome = "qi003_accept")
villmeans <- add.villmean(.data = D_AUDIT_ACCOUNT, .outcome = "MFI_ACCOUNTING")
villmeans <- add.villmean(.data = ABD_INDIV_HEALTH, .outcome = "SUM_HEALTH_INFO")   # Note that this is a cross village interaction in RAPID



dim(villmeans)
head(villmeans)
summary(villmeans)  
summary(villmeans[villmeans$RAPID==1,])  

#pairs(villmeans[,c(8:12)])



# Correlatin plot
panel.cor <- function(x, y, digits=2, prefix="", cex.cor)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r = (cor(x, y, use = "complete.obs"))
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  txt <- paste(prefix, txt, sep="")
  if(missing(cex.cor)) cex <- 0.8/strwidth(txt)
  text(0.5, 0.5, txt, cex = cex * abs(r))
}

panel.smooth2 <- function(x,y) panel.smooth(x,y, col = rgb(0,0,.8,.75), pch = 16, cex = .5)
#pairs(villmeans[,c(8:12)], lower.panel=panel.smooth2, upper.panel=panel.cor)

pdf("Output/correlations.pdf")
pairs(villmeans[,c(8:12)], lower.panel=panel.smooth2, upper.panel=panel.cor,
      labels = c("Amount not verifiable", "Embezzlement\nDirect",  "Embezzlement\nList", 
#                 "Proportion\nPrivate Beneficiaries",
                 "standard deviation\nPrivate Benefits", "Chief dominance"))
dev.off()


summary_stats <- t(sapply(c(3,4,8:ncol(villmeans)), function(j) c(N=sum(!is.na(villmeans[,j])), 
                                        mean = mean(villmeans[,j], na.rm = TRUE),
                                        sd = sd(villmeans[,j], na.rm = TRUE),
                                        min = min(villmeans[,j], na.rm = TRUE),
                                        max = max(villmeans[,j], na.rm = TRUE)
                                        )
       ))

summary_stats[,2:5] <- round(summary_stats[,2:5], 2)

#rapid_only <- c("N","N",ifelse((1:16 %in% c(14,16)), "N", "Y"))
rapid_only <- c("NA","NA",ifelse((1:16 %in% c(14,16)), "N", "Y"))
#mfi_index <-  c("N","N",ifelse((1:16 %in% c(10:13,16)), "Y", "N"))
mfi_index <-  c("NA","NA", rep("N",8),x <-rep("Y",4), "N", "N", "Y", "N")
summary_stats <- cbind(rapid_only, mfi_index, summary_stats)

T_SS <- rbind(
  "\\begin{tabular}{lccccccc}",
  "	Variable &	RAPID only &  Mean Effects & N	&	Mean	&	SD	&	Min. & Max.	 \\\\ \\hline \\hline",
  "\\mc{8}{l}{\\textbf{Village level variables}} \\\\ \\hline",
  mat_to_tex(summary_stats[1:2,], rownames= c("RAPID", "TUUNGANE")) ,
  mat_to_tex(summary_stats[1:16,], rownames= c(varnames[1:16])),
  "\\hline \\hline \\mc{8}{l}{\\parbox{5.8in}{\\small\\singlespace  
  \\textit{Notes:} Summary statistics given at the village mean level. The RAPID column indicates whether data was available only in locations in which the RAPID project was introduced; the mean effects column indicates whether a mean effects index us used in place of multiple related outcome variables. 
For variables analyzed as interactions we report here the difference in mean outcomes between the two relevant groups (ie for the list
experiment the difference between the mean outcomes for the long list and short list subjects, and for chief dominance between the chiefs outcome and average citizen outcome).}
  }",
  
  "\\label{table_ss}",
  "\\end{tabular}"
)

sink("Output/Table_SS.tex")
tablr(T_SS)
sink()

