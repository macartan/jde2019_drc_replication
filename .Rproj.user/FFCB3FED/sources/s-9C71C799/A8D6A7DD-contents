
```{r, echo=FALSE}
set.seed(1)
library(DeclareDesign)
```

## Financial Irregularities

Below we calculate power for different values of the average treatment effect (ATE) based on a simulation approach using the package `DeclareDesign`.

We formally declare our data structure, our potential outcomes, assignment scheme, our estimand and estimators. 

For dependent variables outcomes such as financial irregularities, we draw potential outcomes for control ($Y[Z=0]$) from observed outcomes in the control sample. In the data generating process, we assume $Y[Z=1] = Y[Z=0] + \tau + \epsilon$ where $\tau$ is the average treatment effect and $\epsilon$ the error at the village level (unit of analysis) normally distributed around a mean of 0, with standard deviation of 1.

Note: Here another approach would be to specify ($Y[Z=0]$) for a given cluster as the block-level average with a normally distributed error term for the village. 

```{r}

# Declare Tuungane Design
design_tuungane <- function(df, ate,
                            dv = "da109_not_verifiable"){ # outcomes: Correct_D_projet
  
  Y0obs <- df[df$TUUNGANE == 0, dv, drop = TRUE]
    
  cols <- c("TUUNGANE", "WEIGHT", "LOTT_BIN",
            "IDV", "IDV_CDCCODE", "IDS_CDCCODE",
            "CHIEF", "qr026i_fund_misuse")

  dat <- df[, intersect(names(df), cols)]
  dat$dv <- df[[dv]]
    
  U <- declare_population(data = dat,
                          IDV = modify_level(u_j = rnorm(N)))
  
  Y <- declare_potential_outcomes(
    Y_Z_0 = sample(Y0obs, N, replace = TRUE) + u_j,
    Y_Z_1 = Y_Z_0 + ate + u_j
  )
  
  assign_tuungane <- function(data){
    data <- data %>% arrange(LOTT_BIN)
    block_n <- as.data.frame(table(data$LOTT_BIN))$Freq
    odd <- sapply(block_n, function(x) x%%2==1)
    data$Z <- NA
    for(block in seq_along(unique(dat$LOTT_BIN))){
      v <- rep(c(0,1), floor(block_n[block]/2))
      if(odd[block]){
        v_odd <- 1*as.numeric(runif(1)>.5)
        v <- c(v, v_odd)
      }
      data$Z[data$LOTT_BIN==block] <- sample(v, block_n[block])
    }
    return(data)
  }
  
  Z <- declare_assignment(handler = assign_tuungane)
  
  R <- declare_reveal(Y, Z)
  
  get_weights <- declare_step(handler = 
                                function(data){
                                  data <- group_by(data, LOTT_BIN) %>%
                                    dplyr::mutate(prob_treat = sum(Z == 1)/n()) %>%
                                    ungroup() %>%
                                    dplyr::mutate(ipw = 1/(Z*prob_treat + (1-Z)*(1-prob_treat)))
                                  return(data)
                                }
                                
  )
  
  Q <- declare_estimand(ATE = mean(Y_Z_1 - Y_Z_0, na.rm = TRUE))
  
  
  B <- declare_estimator(Y ~ Z, weights = ipw,
                         estimand = Q,
                         model = lm_robust,
                         label = "tuungane_estimator")
  
  
  design <- U + Y + Z + R + get_weights + Q + B
  return(design)
}

```

We then run 500 simulations of this design assuming ATEs ranging [0,1] for financial irregularities and [0,4] for inequality of private benefits to estimate statistical power.

```{r}
d1_fin_irreg <- design_tuungane(D_AUDIT_NOTVERI, ate = 0, dv = "da109_not_verifiable")
ates = seq(0, 1, length = 9)
d1s <- redesign(d1_fin_irreg, ate = ates)
diagnoses1 <- diagnose_design(d1s, bootstrap_sims = 0)
mde_plot(diagnoses1, "Financial Irregularities")
```

<!-- ### Inequality of (Private) Benefits -->

```{r}
# d3_ineq_ben <- design_tuungane(ABD_INDIV_BEN, ate = 0, dv = "stdev_benefits")
# ates = seq(0, 4, length = 9)
# d3s <- redesign(d3_ineq_ben, ate = ates)
# diagnoses3 <- diagnose_design(d3s, bootstrap_sims = 0)
# mde_plot(diagnoses3, "Inequality of (Private) Benefits", xlim = c(0,3))
```

## Chief's Dominance

For binary dependent variables where we observe individual data with village-level assignment, we first calculate the empirical intra-cluster correlation coefficient (ICC):

```{r}

get_ICC <- function(df = CHIEF_DOM, dv = "Correct_D_projet"){
  df$dv  <- df[, dv, drop = TRUE]  # dep var
  df$e   <- with(df, dv - ave(dv, as.factor(LOTT_BIN), FUN = function(x) mean(x, na.rm = TRUE)))     # residual
  df$e2  <- with(df, e - ave(e, IDS_CDCCODE, FUN = function(x) mean(x, na.rm = TRUE)))
  1 - var(df$e2, na.rm = TRUE)/var(df$e, na.rm = TRUE)
}

ICC_given_gamma <- function(gamma, df = CHIEF_DOM, dv = "Correct_D_projet"){
  set.seed(1)
  df <- df[!is.na(df[,dv]),]
  df$id <- 1:nrow(df)
  df$p_b <- ave(as.numeric(df[,dv, drop = TRUE]), df$LOTT_BIN, FUN = function(x) mean(x, na.rm=TRUE))           # Block level probability
  df <- fabricate(data = df,
                  IDS_CDCCODE = modify_level(u = gamma*rnorm(N), p_c = pnorm(qnorm(p_b) + u)),
                  id  = modify_level(y = draw_binary(p_c)))
  get_ICC(df, dv = "y")
}

```

We set a $\gamma$ parameter for each dependent variable that results in a similar ICC in our model simulation:

```{r}
kable(data.frame(
  embezz_dir_actual = get_ICC(df = ABD_INDIV_DIRECT, dv = "qr026i_fund_misuse"),
  embezz_dir_simuld = ICC_given_gamma(.8, df = ABD_INDIV_DIRECT, dv = "qr026i_fund_misuse"),
  chief_dom_actual = get_ICC(),
  chief_dom_simuld = ICC_given_gamma(1.2)
  ) %>% t(), col.names = "ICC")

```

We define a data generating process in which an individual in block $k$ and village cluster $j$ will have a prior preference for the project actually chosen (in the case of chief dominance analysis) with a probability $p_{jk}$, where $p_{jk}$ is drawn from a distribution centered on the block-level share of individuals whose preferred projects were chosen, with a variance that produces an ICC approximate to the value calculated above using the actual data.

```{r}

design_tuungane2 <- function(df = CHIEF_DOM, gamma = 1.2, delta = 0,
                             dv = "Correct_D_projet"){
  
  cols <- c("TUUNGANE", "WEIGHT", "LOTT_BIN",
            "IDV", "IDV_CDCCODE", "IDS_CDCCODE",
            "CHIEF", "Correct_D_projet", "da109_not_verifiable")

  dat <- df[, intersect(names(df), cols)]
  
  dat$Y_obs <- dat[,dv]   # The observed dependent variable
  dat$p_b   <- ave(dat$Y_obs, dat$LOTT_BIN, FUN = function(x) mean(x, na.rm = TRUE))


  # dat$outcome <- df[[dv]]
  dat$id <- 1:nrow(dat)
  
  U <- declare_population(data = dat,
                          IDV = modify_level(u_c = gamma*rnorm(N),
                                             z_c = (qnorm(p_b) + u_c)),
                          id = modify_level(u_i = rnorm(N)))
  
  Y <- declare_potential_outcomes(
    Y_Z_0 = 1*(u_i < pnorm(z_c)),
    Y_Z_1 = 1*(u_i < pnorm(z_c + delta))
  )
  
  assign_tuungane <- function(data){
    data <- data %>% arrange(LOTT_BIN)
    block_n <- as.data.frame(table(data$LOTT_BIN))$Freq
    odd <- sapply(block_n, function(x) x%%2==1)
    data$Z <- NA
    for(block in seq_along(unique(dat$LOTT_BIN))){
      v <- rep(c(0,1), floor(block_n[block]/2))
      if(odd[block]){
        v_odd <- 1*as.numeric(runif(1)>.5)
        v <- c(v, v_odd)
      }
      data$Z[data$LOTT_BIN==block] <- sample(v, block_n[block])
    }
    return(data)
  }
  
  Z <- declare_assignment(handler = assign_tuungane)
  
  R <- declare_reveal(Y, Z)
  
  B <- declare_estimator(Y ~ CHIEF*Z, weights = ipw,
                         estimand = Q,
                         cluster = IDS_CDCCODE,
                         model = lm_robust)
  
  get_weights <- declare_step(handler = 
                                function(data){
                                  data <- group_by(data, LOTT_BIN) %>%
                                    dplyr::mutate(prob_treat = sum(Z == 1)/n()) %>%
                                    ungroup() %>%
                                    dplyr::mutate(ipw = 1/(Z*prob_treat + (1-Z)*(1-prob_treat)))
                                  return(data)
                                }
                                
  )
  
  Q <- declare_estimand(ATE = mean(Y_Z_1[CHIEF == 1] - Y_Z_0[CHIEF == 1], na.rm = TRUE))
  
  
  B <- declare_estimator(Y ~ Z, weights = ipw,
                           estimand = Q,
                           model = lm_robust)
  
  
  design <- U + Y + Z + R + get_weights + Q + B
  return(design)
  
  
}

```

```{r, echo=FALSE}
# d2_embezz_dir <- design_tuungane(ABD_INDIV_DIRECT, ate = 0,
#                                dv = "qr026i_fund_misuse")
# d2_embezz_dir <- replace_step(d2_embezz_dir, "tuungane_estimator",
#                               declare_estimator(Y ~ Z, weights = ipw,
#                                                 cluster = IDS_CDCCODE, # ADD CLUSTER TO ESTIMATION
#                                                 estimand = "ATE",
#                                                 model = lm_robust))
# 
# ates = seq(0, 1, length = 9)
# d2s <- redesign(d2_embezz_dir, ate = ates)
# diagnoses2 <- diagnose_design(d2s, bootstrap_sims = 0)
# mde_plot(diagnoses2, "Inequality of (Private) Benefits", xlim = c(0,1))
```

```{r}
d5_dom_chief <- design_tuungane2(CHIEF_DOM, delta = 0, dv = "Correct_D_projet")
deltas = seq(0, 1.5, length = 7)
d5s <- redesign(d5_dom_chief, delta = deltas)
diagnoses5 <- diagnose_design(d5s, bootstrap_sims = 0)
mde_plot(diagnoses5, main = "Dominance of Chief's Preferences", xlim = c(0,0.12))
```

```{r,echo=FALSE}
pdf("../Output/Fig_MDE.pdf", width = 3, height = 6)
par(mfrow = c(2,1))
mde_plot(diagnoses1, "Financial Irregularities")
# mde_plot(diagnoses2, main = "Embezzlement (direct)")
# mde_plot(diagnoses3, "Inequality of (Private) Benefits", xlim = c(0,3))
mde_plot(diagnoses5, main = "Dominance of Chief's Preferences", xlim = c(0,0.12))
dev.off()
```

