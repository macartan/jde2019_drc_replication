## Project: Institutional Change by Imitation: Demonstrating the Practice of Democracy in Congolese Villages
## Authors: Humphreys, Sanchez de la Sierra, van der Windt (2018)
## Description: Regenerates map study map with treatment and control villages 
## Date created: Fri Jun 29 17:31:31 2018

# Declare Tuungane Design
design_tuungane <- function(df, ate,
                            outcome = "da109_not_verifiable"){ # outcomes: Correct_D_projet
  
  Y0obs <- df[df$TUUNGANE == 0, outcome, drop = TRUE]
    
  cols <- c("TUUNGANE", "WEIGHT", "LOTT_BIN",
            "IDV", "IDV_CDCCODE", "IDS_CDCCODE",
            "CHIEF")

  dat <- df[, intersect(names(df), cols)]
  dat$outcome <- df[[outcome]]
    
  U <- declare_population(data = dat,
                          IDV = modify_level(u_j = rnorm(N)))
  
  Y <- declare_potential_outcomes(
    Y_Z_0 = sample(Y0obs, N, replace = TRUE) + u_j,
    Y_Z_1 = Y_Z_0 + ate + u_j
  )
  
  assign_tuungane <- function(data){
    data <- data %>% arrange(LOTT_BIN)
    block_n <- as.data.frame(table(data$LOTT_BIN))$Freq
    odd <- sapply(block_n, function(x) x%%2==1)
    data$Z <- NA
    for(block in seq_along(unique(dat$LOTT_BIN))){
      v <- rep(c(0,1), floor(block_n[block]/2))
      if(odd[block]){
        v_odd <- 1*as.numeric(runif(1)>.5)
        v <- c(v, v_odd)
      }
      data$Z[data$LOTT_BIN==block] <- sample(v, block_n[block])
    }
    return(data)
  }
  
  Z <- declare_assignment(handler = assign_tuungane)
  
  R <- declare_reveal(Y, Z)
  
  get_weights <- declare_step(handler = 
                                function(data){
                                  data <- group_by(data, LOTT_BIN) %>%
                                    dplyr::mutate(prob_treat = sum(Z == 1)/n()) %>%
                                    ungroup() %>%
                                    dplyr::mutate(ipw = 1/(Z*prob_treat + (1-Z)*(1-prob_treat)))
                                  return(data)
                                }
                                
  )
  
  Q <- declare_estimand(ATE = mean(Y_Z_1 - Y_Z_0, na.rm = TRUE))
  
  if(outcome == "Correct_D_projet"){
    B <- declare_estimator(Y ~ CHIEF*Z, weights = ipw,
                           estimand = Q,
                           cluster = IDS_CDCCODE,
                           model = lm_robust)#,
                           # coefficients = c("CHIEF", "CHIEFTRUE"))
  }else{
    B <- declare_estimator(Y ~ Z, weights = ipw,
                           estimand = Q,
                           model = lm_robust)
  }
  
  
  design <- U + Y + Z + R + get_weights + Q + B
  return(design)
}

# Plot function
mde_plot <- function(diagnoses, main = ""){
  plot(abs(diagnoses[[2]]$mean_estimand), diagnoses[[2]]$power, ylim = c(0,1), xlim = c(0,1), 
       main = main, xlab = "ATE (Absolute Value)", ylab = "power", type = "b")
  abline(a = .8, b = 0)
}

# Outcome 1: Financial Irregularities
d1_fin_irreg <- design_tuungane(D_AUDIT_NOTVERI, ate = 0, outcome = "da109_not_verifiable")
ates = seq(0, 1, length = 10)
d1s <- redesign(d1_fin_irreg, ate = ates)
diagnoses1 <- diagnose_design(d1s, bootstrap_sims = 0)
mde_plot(diagnoses1, "Financial Irregularities")

# Outcome 2: Dominance of Chief's Preferences
d2_dom_chief <- design_tuungane(CHIEF_DOM, ate = 0, outcome = "Correct_D_projet")
ates = seq(0, 1, length = 9)
d2s <- redesign(d2_dom_chief, ate = ates)
diagnoses2 <- diagnose_design(d1s, bootstrap_sims = 0)
mde_plot(diagnoses2, main = "Dominance of Chief's Preferences")

get_ICC <- function(df = CHIEF_DOM, dv = "Correct_D_projet"){
  df$dv  <- df[, dv]                         # dep var
  df$e   <- with(df, dv - ave(dv, LOTT_BIN, FUN = function(x) mean(x, na.rm = TRUE)))     # residual
  df$e2  <- with(df, e - ave(e, IDS_CDCCODE, FUN = function(x) mean(x, na.rm = TRUE)))
  1 - var(df$e2, na.rm = TRUE)/var(df$e, na.rm = TRUE)
}

get_ICC()

ICC_given_gamma <- function(gamma, df = CHIEF_DOM, dv = "Correct_D_projet"){
  df <- df[!is.na(df[,dv]),]
  df$id <- 1:nrow(df)
  df$p_b <- ave(as.numeric(df[,dv]), df$LOTT_BIN, FUN = function(x) mean(x, na.rm=TRUE))           # Block level probability
  df <- fabricate(data = df,
                  IDS_CDCCODE = modify_level(u = gamma*rnorm(N), p_c = pnorm(qnorm(p_b) + u)),
                  id  = modify_level(y = draw_binary(p_c)))
  get_ICC(df, dv = "y")
}

ICC_given_gamma(1.2)
get_ICC()

# # Calculate parameters of beta distribution
# mu <- mean(D_AUDIT_NOTVERI$da109_not_verifiable, na.rm = TRUE)
# var <- var(D_AUDIT_NOTVERI$da109_not_verifiable, na.rm = TRUE)
# 
# estBetaParams <- function(mu, var) {
#   alpha <- ((1 - mu) / var - 1 / mu) * mu ^ 2
#   beta <- alpha * (1 / mu - 1)
#   return(params = list(alpha = alpha, beta = beta))
# }
# 
# betapar <- estBetaParams(mu, var)
# Y <-  rbeta(n=1000, shape1 = betapar$alpha, shape2 = betapar$beta)
# Yobs <- na.omit(D_AUDIT_NOTVERI_0$da109_not_verifiable)
# Yobs[Yobs == 0] <- 0.0001
# #Null hypothesis that the empirical dist of Y is equal to beta dist w parameter mu, var 
# goftest::ad.test(na.omit(Yobs), null = "pbeta", shape1 = betapar$alpha, shape2 = betapar$beta)

